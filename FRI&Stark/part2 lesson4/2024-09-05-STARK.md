---
layout: post
title: STARK
categories: STARK, soundness
author: Yingfei
---
本文主要介绍STRAK协议的形式化定义及安全性讨论，会从密码学的角度描述STRAK协议，主要参考文献为ethSTARK。本文默认读者已经熟悉STARK协议的流程。

## STARK协议

本节我们将形式化描述STARK协议，首先介绍AIR，随后给出STARK（IOP）协议的细节。

### AIR

**定义1（AIR）** 一个algebraic intermediate representation (AIR)是由tuple $\mathsf{A}=(\mathbb{F}, w, h, d, s, g, I, Cset)$组成的， 其中
- $\mathbb{F}$是一个有限域；
- $w, h, d, s$是一些整数；
	- $w$是trace的列数。
	- $s$是constraints集合的size。
	- $d$是一个constraint的最高degree。
	- $h$表示trace domain $\mathsf{H}_0$中使用的乘法子群的size的对数，即，$|\mathsf{H}_0| = 2^h$。
- $g$是乘法群$\mathsf{H}_0 \subset \mathbb{F}^*$的生成元，因此 $|\mathsf{H}_0| =2^h$；
- $I\subseteq \{1,...,w\} \times \{0, ...,2^h-1\}$是mask indices的集合。定义$Y=\{Y_{i,j}:{i,j}\in I\}$是由$I$中元素索引的mask variables；
- $Cset = \{C_1, ... C_s\}$ 是constraints的有限集合，大小为s。每个constraint都由$s$个有序对$C_i = (Q_i, \mathsf{H}_i)$组成。
	- $Q_i \in \mathbb{F}^{\leq d}[Y]$是一个关于mask variables的多变量多项式，总degree至多为$d$，称为第$i$个 constraint polynomial.
	- $\mathsf{H}_i \subseteq \mathsf{H}_0$是trace domain的子集，称为第$i$个constraint enforcement domain．
	- 用$|Cset|$表示the arithmetic complexity of the constraints，定义为$|Cset| \sum^s_{i=1} (|Q_i|+ |\mathsf{H}_i|)$，其中，$|Q_i|$是计算多项式$Q_i$的算术电路，$|\mathsf{H}_i|$是vanishing polynomial $\mathsf{Z}_{\mathsf{H}_i}$的算术复杂度。

**定义2 (AIR assignment and composition)** 一个AIR assignment是由一组多项式$\vec{P} = (P_1, ..., P_w) \in \mathbb{F}[X]^w$ 组成的。
给定一个AIR约束多项式$Q\in \mathbb{F}[Y]$，那么$Q$的composition 和 assignment $\vec{P}$ 是一个单变元多项式，用$Q \circ \vec{P} \in \mathbb{F}[X]$表示。它是通过用$P_i(g^j\cdot X) \in \mathbb{F}[X]$ 替换$Q(Y)$中的变量 $Y_{i,j} \in Y$得到的，我们用$Y_{i,j} \gets P_i(g^j \cdot X)$来简化表示这个替换。

**定义3 （Satisfiability）** 一个AIR assignment $\vec{P} = (P_1, ..., P_w) \in \mathbb{F}[X]^w$满足一个AIR实例$\mathsf{A}=(\mathbb{F}, w, h, d, s, g, I, Cset)$当且仅当
$$\forall i \in [s]: x\in \mathsf{H}_i \to (Q \circ \vec{P})(x) = 0.$$
换句话说，$\vec{P}$满足$\mathsf{A}$ 当且仅当 对于每个constraint $C_i=(Q_i, \mathsf{H}_i) \in Cset$， $Q \circ \vec{P}$ vanishes on $\mathsf{H}_i$。

vanish：多项式$\mathsf{Z}_{\mathsf{H}_i}(X)$在$\mathbb{F}[X]$上整除多项式$Q \circ \vec{P}$。

用大家习惯的statement和witness的方式来表达，在STARK中，statement是一个AIR实例$\mathsf{A}=(\mathbb{F}, w, h, d, s, g, I, Cset)$，它定义了协议需要的公开参数以及寄存器之间的约束关系，witness则是AIR assignment $\vec{P} = (P_1, ..., P_w)$，也就是trace多项式。

### 协议

在描述协议之前，我们先介绍一些辅助输入aux。
- $\mathbb{K}$ 是有限域 $\mathbb{F}_q$ 的有限扩张，size为 $q^e, e\geq1$。为了简便，全文符号对 $\mathbb{F}$ 和$\mathbb{F}_q$ 不做区分。
- $\mathsf{D} \subset \mathbb{K}^*$是乘法子群 $\mathsf{D}_0 \subset \mathbb{K}^*$的非平凡陪集。称$\mathsf{D}$为evaluation domain。recall：AIR的trace domain $\mathsf{H}_0 \subset \mathsf{D}_0$。
- $k'$表示$|\mathsf{D}|$的对数，即 $|\mathsf{D}| = 2^{k'}$。
- $\rho = 2^h/2^{k'}$ 表示IOP协议的rate， $\rho^{-1}$为blowup factor. 
- $\mathsf{aux}_{\mathsf{FRI}}$定义为FRI协议的辅助输入。

在实际协议中，上述$\mathsf{D}$是LDE的input domain。注意，$\mathsf{D}$与AIR的trace domain $\mathsf{H}_0$ （trace函数的input domain）是互不相交的。这是为了避免LDE的商多项式的分母为0。

我们还会用到下列符号：
- $\mathsf{Quotient} : \mathsf{D} \to \mathbb{F}$： 对于 $(x_0, y_0) \in \mathbb{K}/\mathsf{D} \times \mathbb{K}$ 和函数$f : \mathsf{D} \to \mathbb{K}$，定义函数$f$的quotient 如下：$$\mathsf{Quotient}(f; x_0, y_0) (x)  = \frac{f(x)-y_0}{x-x_0}.$$
- $\mathsf{RS}[\mathbb{K},S, \rho]$ 表示定义在域$\mathbb{K}$上的Reed-Solomon码，其evaluation domain为 $S$，码率 rate是$\rho$。 $$\mathsf{RS}[\mathbb{K},S, \rho] = \{f: S\to \mathbb{K}: deg(f) < \rho|S| \}$$
下面，我们开始描述协议。

**$\mathcal{P,V}$ 的公共输入**：AIR实例 $\mathsf{A}=(\mathbb{F}, w, h, d, s, g, I, Cset)$ 和IOP辅助输入  $\mathsf{aux}=(\mathbb{K}, e, \mathsf{D}, k', \mathsf{aux}_{\mathsf{FRI}})$。
**$\mathcal{P}$ 的秘密输入**：AIR assignment $\vec{P} = (P_1, ..., P_w) \in \mathbb{F}[X]^w$。

0. **预处理**：
	- Constraint weighted degree：对每个constraint $C_i=(Q_i, \mathsf{H}_i) \in Cset$，定义第$i$个composed degree $d_i = deg(Q_i)\cdot (2^h-1) - |\mathsf{H}_i|$。
	- Designated degree：定义$d_{max}$是比上述最大的$d_i$严格大的一个2个幂次整数。定义$a= d_{max}/2^h$.
	- Degree correction：对每个constraint $C_i=(Q_i, \mathsf{H}_i) \in Cset$，定义degree correction参数$c_i = d_{max}-d_i - 1$。
	这一步的预处理是为了在Step2确定degree adjustment的次数，便于把高次多项式拆成$a$个与trace多项式次数相同的多项式。
1. **执行trace oracle**：证明者发送oracle functions $f_1, ..., f_w : \mathsf{D} \to \mathbb{K}$。
	函数$f_i$是满足AIR的多项式$P_i(X)\in \mathbb{F}$，在evaluation domain $\mathsf{D}$上计算得到的Evaluation。即，对于 $\forall x \in \mathsf{D}$，计算所有$P_i(x)$的取值组成$f_i$。
	note：
	- $P_i(X)$的次数 $deg(P_i)<2^h$。
	- 如果$\mathsf{D} \subset \mathbb{F}$，那么 $f_1, ..., f_w$的取值就在$\mathbb{F}$上。这与$\mathsf{D}$和AIR的trace domain $\mathsf{H}_0$ 互不相交并不冲突。
2. **constraints线性组合**：验证者选择$2s$个随机值 $\vec{r} = (r_1, r_1', ..., r_s, r_s') \in \mathbb{K}^{2s}$发送给$\mathcal{P}$。随后$\mathcal{P, V}$共同把AIR实例中的s个constraints全部随机组合起来，得到变量$(X,Y)$的一个rational函数 $Q^{\vec{r}}(X,Y)$：$$Q^{\vec{r}}(X,Y):= \sum_{i=1}^s \left( r_i + r_i' X^{c_i}\right)\cdot \frac{Q_i(Y)}{Z_\mathsf{H_i}(X)}$$
	在prover这端，$Y_{i,j}$已经被$P_i(g^jX)$替换了。由于每个$P_i$的次数严格小于$2^h$，而且$Q \circ \vec{P}$ vanishes on $\mathsf{H}_i$，因此等号右侧可以总结成一个关于变量$X$的多项式$R^{\vec{r}}_i(X)$，该多项式的degree小于$d_{max}$。

3. **constraint trace oracle**：$\mathcal{P}$ 发送oracle函数$f_0^{\vec{r}}, ..., f_{a-1}^{\vec{r}} : \mathsf{D} \to \mathbb{K}$。
	每个函数$f_i^{\vec{r}}$都是多项式$P_i^{\vec{r}}(X)$在$\mathsf{D}$上的evaluation，满足：$$\left(Q^{\vec{r}}(X,Y) \circ \vec{P} \right)(X) = \sum^{a-1}_{k=0} X^k \cdot P_k^{\vec{r}}(X^a).$$
	由于在 Step4 中线性组合的多项式 $R^{\vec{r}}_i(X)$ degree小于$d_{max}$，超过了trace evaluation domain的size。为了与trace的多项式$P_i$ 线性组合，一起做FRI验证low degree，所以需要拆成多个小degree组合。

	拆分方式为：拆成$a= d_{max}/2^h$个多项式，每个$P_i^{\vec{r}}(X)$以$a$为次数的间隔，取原多项式中的对应系数。所以最终得到的每个多项式$P_i^{\vec{r}}(X)$的degree均小于$2^h$。

4. **DEEP Query**： $\mathcal{V}$ 从 $\mathbb{K}* \setminus (\mathsf{H}_0 \cap \bar{\mathsf{D}})$ 采样一个随机值 $\mathsf{q}$。集合$\bar{\mathsf{D}} = \{y \in \mathbb{K}* : y^{a} \in \mathsf{D}\}$。排除集合 $\mathsf{H}_0$ 是为了保证计算answer $\alpha$ 时 $\mathsf{q} \cdot g^j$ 不会重叠到另一个$g^k$，排除集合 $\bar{\mathsf{D}}$ 是为了避免计算商多项式时分母为0。

5. **DEEP Answer**： $\mathcal{P}$ 发送 answer 序列 $\{\alpha_{i,j}: (i,j) \in I\} \cup \{ \beta_k: k \in\{0, ..., a-1\}\}$。其中：$$\alpha_{i,j} = P_i(\mathsf{q} \cdot g^j), \beta_k = P_k^{\vec{r}}(\mathsf{q}^a)$$
	若等式 $Q^{\vec{r}}(\mathsf{q},\{Y_{i,j} \gets \alpha_{i,j}\}) = \sum^{a-1}_{k=0} \mathsf{q}^k \cdot \beta_k$成立，则称约束$Q^{\vec{r}}(X,Y)$ 在该answer下是验证有效的。 $\{Y_{i,j} \gets \alpha_{i,j}\}$表示用$\alpha_{i,j}$替换$Y_{i,j}$。

6. **FRI 线性组合**： $\mathcal{V}$ 采样随机值 $$r^F = \{r^F_{(i,j)}: (i,j) \in I\} \cup \{r^F_k: k \in\{0, ..., a-1\}\} \in \mathbb{K}^{I\cup[a]}$$ 并发送给$\mathcal{P}$。

7.  **FRI协议**：$\mathcal{P, V}$共同利用FRI协议的辅助输入$\mathsf{aux}_{\mathsf{FRI}}$，执行FRI协议，验证 proximity to 函数 $g_{(\vec{r},q,answer, r^F)}:\mathsf{D} \to \mathbb{K}$ 的RS码 $\mathsf{RS}[\mathbb{K},\mathsf{D}, \rho]$。其中，$$g_{(\vec{r},\mathsf{q}, answer, r^F)}:= \sum_{(i,j) \in I} r^F_{(i,j)}\cdot \mathsf{Quotient}(f_i; \mathsf{q}\cdot g^j, \alpha_{i,j})(x) + \sum_{k=0}^{a-1}\mathsf{Quotient}(f_k^{\vec{r}}; \mathsf{q}^a, \beta_k)(x).$$
8. **协议验证**：$\mathcal{V}$ 接受条件：
	1. FRI 协议接受$g_{(\vec{r},q,answer, r^F)}$ ;
	2. $Q^{\vec{r}}(X,Y)$ 在该answer下是验证有效的。


## STARK安全性
### 基础定义

下面我们简单描述IOP协议涉及的几个安全性定义。
Completeness 说明了诚实执行协议的证明者与诚实执行协议的验证者交互，最终验证者会（以指数接近1的概率）接受证明。

Soundness 指的是，如果（恶意的）证明者证明的statement是错误的，在上述协议中，即$\mathsf{A}$不是AIR实例，那么验证者会（以指数接近1的概率，$1-\epsilon$）拒绝证明。

Knowledge Soundness 是说，如果（恶意的）证明者要证明的statement是正确的，验证者以某一个概率接受了证明，则存在一个概率多项式时间的提取器，可以从证明者与验证者的交互中提取出statement对应的witness。

以上述协议为例，如果 $\mathsf{A}$ 是AIR实例，验证者以$\epsilon$概率接受了证明，那么我们可以提取出$\mathsf{A}$对应的trace 多项式$\vec{P}$。

这个定义意味着恶意的证明者如果能生成正确的证明，则代表这个证明者获得了statement (AIR实例) 的witness。上述定义中提到的$\epsilon$称为soundness error。

做安全性证明需要注意的一些细节：
- 提取器的输入和验证者一样。
- 提取器可以调用恶意的证明者作为自己的子程序，但需要注意这个恶意的证明者也没有witness。

### 安全性分析需要用到的几个定理

首先，我们需要从编码的角度去看STARK协议中出现的多项式：向量$f$是words，AIR的assignment是RS code的codewords。

**定理1** （Johnson bound）对于所有的$\eta \in (0, 1-\sqrt{\rho})$，编码$V$是$(1-\sqrt{\rho}-\eta, \frac{1}{2\eta \sqrt{\rho}})$- list-decodable。

这个定理说明了，对于一个向量$u \in \mathbb{F}^n_q$，在码 (code) $V\subset \mathbb{F}^n$上，至多存在$\ell = \frac{1}{2\eta \sqrt{\rho}}$个的码字 (codeword)，与$u$的相关汉明距离（relative Hamming distance）不超过$\gamma = 1-\sqrt{\rho}-\eta$。

**定理2** （Guruswami–Sudan list decoding）GS list decoding算法输入一个word $u:\mathsf{D} \to \mathbb{F}_q$，一个RS码$V = \mathsf{RS}[\mathbb{F},\mathsf{D}, \rho]$，一个slackness参数$\eta>0$，输出$V$中agree with $u$ 的一组码字（agreement domain $S$），density至少是D的$\sqrt{\rho} +\eta$。该算法的期望时间是 $n, 1/\rho, 1/\eta$ 和 $\log q$ 的多项式级别。

agree with：在agreement domain $S$ 上，word $u$ 与码字 $v$ 满足：$\forall x \in S, u(x) = v(x)$。
density：agreement domain的 size 与 word $u$ 的全部input比值 $\sigma \leq|S| / |\mathsf{D}|$。

因为agree考虑的是$x$ 从 $S$ 集合中取值时codeword与word的值是否相同，density也考虑的是 $x$ 在 $S$ 集合取值与原本 $x$ 在 $\mathsf{D}$ 中任意取值的情况，即两个集合的size对比。

下一部分knowledge soundness的提取器将会用到定理2介绍的解码算法。在此之前，我们需要先扩展上述算法到多组words的联合解码。

**定义4**（Correlated agreement）定义向量集合$V\subset \mathbb{K}^{\mathsf{D}}$，$W=\{w_1, ..., w_k\}$，其中每个$w_i \in \mathbb{K}^{\mathsf{D}}$。定义agreement参数$\sigma \in [0,1]$。称$W$与$V$在 agreement domain $S \subset \mathsf{D}$ 上以density $\sigma$ 相关一致(correlated agree)，如果满足：
- $\sigma \leq|S| / |\mathsf{D}|$，
- 存在$v_1, ..., v_k \in V$，使得，$w_i$ 在 $S$ 上与 $v_i$ agree，即$\forall x \in S, w_i(x) = v_i(x)$。

我们称S是一个最大agreement domain如果它不真包含 ($\subsetneq$) 在任何一个agreement domain里。

下面我们介绍RS算法的一个推导引理，这个引理将直接用于构造STARK协议的知识提取器。

**引理1**（Correlated agreement list decoder）定义RS码$V = \mathsf{RS}[\mathbb{F},\mathsf{D}, \rho]$，向量集合$W=\{w_1, ..., w_k\}$，其中每个$w_i \in \mathbb{K}^{\mathsf{D}}$。定义$\sigma = \sqrt{\rho} + \eta, \eta>0$是一个agreement density参数。存在一个随机化算法，期望运行时间是 $1/\rho, 1/\eta, k, \log{|\mathbb{K}|}$ 的多项式级别，该算法输出一个列表$\mathcal{S}=\{S_1, ..., S_{\ell} \}$。该列表是所有density至少为$\sigma$的最大agreement domain，满足$\ell \leq 1/(2\eta\sqrt{\rho})$。此外，每一组$S_i, w_j \in W, v_{i,j} \in V$都满足$w_j$ 在 $S_i$ 上与 $v_{i,j}$ agree。

这个算法是通过多次调用GS列表解码算法，并对算法输出的agreement domain逐次求交集得到的，而$\ell \leq 1/(2\eta\sqrt{\rho})$这个条件则是直接应用Johnson bound得到的结论。
在此暂时忽略该引理的证明。


### 安全性证明

#### 安全性定理

定理3给出了STARK协议的soundness error上界。

**定理3** （Knowledge Soundness）若验证者 $\mathcal{V}$ 满足条件1和2，则存在一个可以成功输出AIR assignment， 即$\vec{P}= {P_1},...,{P_w}$ 的knowledge extractor $\mathcal{E}(\mathsf{A}=(\mathbb{F}, w, h, d, s, g, I, Cset), \mathsf{aux}, f=(f_1, ..., f_w))$。如果 $\mathcal{V}$ 满足以下条件：
1.  在FRI的Query阶段，$\mathcal{V}$ 调用FRI的验证者 $\mathsf{s}$ 次。
2. 存在一个证明者$\mathcal{P}^*(\mathsf{A}, \mathsf{aux})$ 在Step1 oracle发送$f=(f_1, ..., f_w)$， 且$\mathcal{V}$与$\mathcal{P}$交互时，$\mathcal{V}$接受的概率大于 $$\epsilon_{total} = \frac{\ell}{|\mathbb{K}|} + \frac{(d_{max}+2^h + a) \cdot \ell}{|\mathbb{K}|-a|\mathsf{D}| + |\mathsf{H}_0|} + \epsilon_{\mathsf{FRI}}(q,n,\rho, m,s,\vec{t}),$$ 其中整数$m\geq2, \ell=m/\rho$.

这个定理说明，存在一个提取器可以提取AIR的witness，但这个提取器要输入LDE的多项式$f$。STARK的PIOP中，$f$不是直接发送给验证者的，因此，我们不能直接利用定理4证明STARK协议的knowledge soundness，需要做一点转化。这个转化需要借用下面的推论。

**推论1**（Knowledge extraction from sufficiently convincing prover）给定整数$R\geq1, m\geq3$, 给定$\mathsf{A}=(\mathbb{F}, w, h, d, s, g, I, Cset), \mathsf{aux}=(\mathbb{K}, e, \mathsf{D},k',\mathsf{aux}_{\mathsf{FRI}})$以及$\mathsf{aux}_{\mathsf{FRI}}=(\vec{t},s)$, $2^{-R}=2^h/2^{k'}$。假设存在证明者$\mathcal{P}^*$，满足
$$\Pr[\langle \mathcal{V}(\mathsf{A, aux}, ), \mathcal{P}(\mathsf{A, aux})\rangle = accept] \geq 2\cdot \epsilon_{total},$$
那么， $\mathsf{A} \in \mathcal{L}_{\mathsf{AIR}}$，即 $\mathsf{A}$ 是$\mathsf{AIR}$实例， 且存在一个knowledge extractor $\mathcal{E}'$，在输入$(\mathsf{A, aux})$时，与$\mathcal{P}^*$交互可以输出满足 $\mathsf{A}$的assignment，提取器的期望运行时间为$(w,2^h, d, |Cset|, \log|\mathbb{F}|,1/\epsilon)$的多项式。

**构造$\mathcal{E}'$**：$\mathcal{E}'$重复执行如下步骤$1/\epsilon_{total}$次
- 调用$\mathcal{P}^*$ 并读取oracle $f = (f_1,...,f_w)$；
- 调用定理4中的提取器$\mathcal{E}(\mathsf{A,aux},f)$。

$\mathcal{E}'$不需要输入$f$，因此可以直接用在STARK的证明里，因此，我们可以通过合适的取值使得soundness error是一个可忽略的函数（安全参数的指数分之一，例如$2^{-128}$），证明上述STARK协议是一个knowledge soundness error至多为$\epsilon$的Scalalbe Transparent IOP of Knowledge协议，满足completeness和knowledge soundness。

$\epsilon$ 是随机算法Las Vegas algorithm的优势。

#### Knowledge Extractor的构造

现在介绍如何构造定理3中提到的knowledge extractor $\mathcal{E}$。

$\mathcal{E}$的输入是$\mathsf{A}=(\mathbb{F}, w, h, d, s, g, I, Cset), \mathsf{aux}, f=(f_1, ..., f_w)$，其中$\mathsf{aux} = (\mathbb{K}, e, \mathsf{D}, k', \mathsf{aux}_{\mathsf{FRI}})$是协议的辅助输入。提取器$\mathcal{E}$可以从证明者的第一个oracle function $(f_1, ..., f_w)$ 中提取AIR的assignment $\vec{P}$。
- 准备：$\rho = 2^h/|\mathsf{D}|$。定义$\rho^+ =\frac{2^h+1}{|\mathsf{D}|}$. $\mathsf{RS}[\mathbb{F},\mathsf{D}, \rho]$的码字都是degree小于$2^h$的多项式的求值，所以$\mathsf{RS}[\mathbb{F},\mathsf{D}, \rho^+]$的码字对应的多项式degree都小于$2^h$。
- $\mathcal{E}$首先以 agreement参数$\sqrt{\rho^+}(1+\frac{1}{2m})$， 向量集合$U=\{f_1, ..., f_w\} \subset (\mathbb{F}^{\mathsf{D}})^w$ 和RS码$\mathsf{RS}[\mathbb{F},\mathsf{D}, \rho^+]$ 调用引理1的解码器。定义列表$\mathcal{S}=\{S_1, ..., S_{\ell} \}$ 为算法输出的agreement domain，其density大于等于$\sqrt{\rho^+}(1+\frac{1}{2m})$。定义$\mathcal{P}=\{\vec{P}_1, ..., \vec{P}_{\ell} \}$ 是对应的多项式集合，其中$\vec{P}_i = {P_{i,1},..., P_{i,w}} \in \mathbb{F}^{\leq 2^h[X]}$是与$f_j$在$S_i$上agree的多项式序列，每个$P_{i,j}$的次数都小于$2^h$。
- 对于$k=1,...,\ell$，依次检验$\vec{P}_k$是否满足AIR实例$\mathsf{A}$，如果满足则输出$\vec{P}_k$作为assignment $\vec{P}$；否则输出失败终止算法。

根据定义2，每个$\vec{P}_i$都是一个AIR assignment，$\vec{P}_i$包含的多项式在$\mathbb{F}$上。

因为每个$\vec{P}_i$中的多项式$P_{i,j}$都与$f_j$在集合$S_i$中取值一致
如果$S_i= H_i$，那么$\vec{P}_i$就是assignment。

#### 证明定理3（Knowledge Soundness）

上一节我们已经给出了提取器的构造，这一节，我们继续讨论定理3证明soundness error。

在这个证明中我们做一些简化的假设。

- 证明者$\mathcal{P}(\mathsf{A,aux})$是确定算法。特别是
  - 对于每个 $\vec{r}$，Step3中证明者的oracle functions $f^\vec{r}_0, ..., f^\vec{r}_{a-1}$, 由 $\vec{r}$ 唯一确定，
  - Step5 中的answer序列 $(\alpha, \beta)$ 由$\vec{r}$ 唯一确定。
- answer序列的有效性验证约束 $Q^\vec{r}(X,Y)$ 对于所有 $\vec{r}$ 和 $\mathsf{q}$都成立。

上一部分我们讨论过，提取器$\mathcal{E}$在输入$f_1,...,f_w$时，输出为$(\mathcal{S,P})$，$\mathcal{S}=\{S_1, ..., S_{\ell} \}$是density大于等于$\sqrt{\rho^+}(1+\frac{1}{2m})$的agreement domains集合，$\mathcal{P}=\{ \vec{P}_1,...,\vec{P}_\ell \}$ 都是AIR assignment。$\mathcal{P}$中的每个多项式序列都与$f_1,...,f_w$对应一致。

设置$\eta = \frac{\sqrt{\rho^+}}{2m}$， 根据定理1（Johnson bound）我们可以得到$\ell \leq m/\rho^+ \leq m/\rho$。

接下来把$(f^\vec{r}_0, ..., f^\vec{r}_{a-1})$加到$(f_1,...,f_w)$后面，得到一个更大的序列。然后应用RS码的解码器Correlated agreement list decoder，设置agreement参数$\sqrt{\rho^+} + \eta, \eta = \frac{\sqrt{\rho^+}}{2m}$。把得到的agreement domain记为$\mathcal{S}^\vec{r} = \{ S_1^\vec{r}, ..., S_\ell^\vec{r} \}$，其density是$\sqrt{\rho^+} + \eta$。

因为在相关解码器中，我们一直对$\mathcal{S}$求交集，所以每个 $S_i^\vec{r}$ 都一定包含在某个 $S_k \in \mathcal{S}$中。由于$S_i^\vec{r}$的density大于 $\rho^+$，所以函数$(f_1,...,f_w)$，在$\mathcal{S}_i^\vec{r}$ domain中的所有元素的取值，都与$\vec{P}_k$一致。这种情况我们称为$\mathcal{S}_i^\vec{r}$ 与$\vec{P}_k$相关联(associated with)。

定义 $\vec{P}_i^{\vec{r}} = (P_0^{\vec{r}},..., P_{a-1}^{\vec{r}})$ 是次数$\leq 2^h$，与$(f^\vec{r}_0, ..., f^\vec{r}_{a-1})$ 在$S_\ell^\vec{r}$ agree的多项式序列，定义$\mathcal{P}^\vec{r} = \{\vec{P}_1^{\vec{r}},...,\vec{P}_\ell^{\vec{r}}\}$。由于$\mathcal{S}_i^\vec{r}$ 与$\vec{P}_k$相关联，$\vec{P}_i^{\vec{r}}$与$\mathcal{S}_i^\vec{r}$ 相关联，所以我们也称$\vec{P}_i^{\vec{r}}$与$\vec{P}_k$相关联。

上述说明了多项式之间的关联是存在的，下面我们希望把这种关联在固定在随机挑战值上，保证证明能被验证者接受，以此证明$\vec{P}_k$是合法的witness。

定义Good$(\vec{r},\mathsf{q})$ 为FRI协议接受概率大于$\epsilon_{\mathsf{FRI}}$的取值。

**引理2** 对于Good$(\vec{r},\mathsf{q})$，存在：
- AIR assignment $\vec{P}_k = \{P_{k,1},..., P_{k,w}\} \in \mathcal{P}$
- 多项式序列$\vec{P}^{\vec{r}} = (P_0^{\vec{r}},..., P_{a-1}^{\vec{r}})$ 与$\vec{P}_k$ 相关联。
- $S_{(\vec{r},\mathsf{q})} \subset S_k$
使得下列条件都成立：
1. $|S_{(\vec{r},\mathsf{q})}| > (\sqrt{\rho^+} + \eta) |\mathsf{D}|$
2. 每个$P_{k,i}$都与$f_i$在$S_{(\vec{r},\mathsf{q})}$ agree
3. $P_{k,i}$的取值与DEEP answer $\alpha_{i,j}$ 全部匹配。$P_{k,i}(\mathsf{q}g^j) = \alpha_{i,j}$
4. $P_{l}^{\vec{r}}$与$f_{l}^{\vec{r}}$ 在 $S_{(\vec{r},\mathsf{q})}$ agree
5. $P_{l}^{\vec{r}}$的取值与DEEP answer $\beta_{l}$ 全部匹配。

条件2-5保证了DEEP answer是可以验证有效的。
这条引理说明了Good$(\vec{r},\mathsf{q})$ 能让验证者接受FRI的证明，也保证DEEP的answer可以验证有效，这两点同时保证了验证者会接受STARK的证明。

下面，我们希望说明，满足Good$(\vec{r},\mathsf{q})$的随机值 $(\vec{r},\mathsf{q})$取值有足够多，这一点可以保证我们提取的$\vec{P}_k$是合法的。

定义Useful$(\vec{r})$为能保证$\mathsf{q}$ 的取值足够多，的$\vec{r}$的取值。
- $\mathsf{q}$ 的取值指的是让Good$(\vec{r},\mathsf{q})$ 条件在$\vec{P}_k \in \mathcal{P}$成立的那些取值。
- 足够多指的是，$>((a+1) \cdot |\mathsf{H}_0| + a) \cdot \ell= (d_{max} + 2^h + a) \cdot \ell$

**引理3**对于Useful$(\vec{r})$，函数$Q^{\vec{r}}(X,Y) \circ \vec{P}_k$是有限域$\mathbb{K}$上的多项式。

**引理4** 如果线性独立的随机值$({r}_1, ..., {r}_{2s}) \in \mathbb{K}^{2s}$都对于某个函数序列$\vec{P}_k$是useful，那么$\vec{P}_k$满足AIR实例$\mathsf{A}$。

引理3说明了$\vec{P}_k$是assignment，引理4则说明了$\vec{P}_k$满足我们要求的AIR实例$\mathsf{A}$。这样，我们基本完成了提取器的构造和说明，下面简单讨论soundness error的上界是如何得到的。

接下来，我们限制随机值$\vec{r}$ is not useful概率。如果$\vec{r}$ not useful，那么对于每组assignment $\vec{P}_k$，至多有$(d_{max} + 2^h + a) \cdot \ell$个$\mathsf{q}$的取值是Good$(\vec{r},\mathsf{q})$。
那么对于所有的assignment $\mathcal{P}$，总共有$(d_{max} + 2^h + a) \cdot \ell |\mathcal{P}| = ((a+1) \cdot 2^h + a) \cdot \ell^2$个$\mathsf{q}$的取值使得FRI的接受概率大于等于$\epsilon_{\mathsf{FRI}}$。
那么，STARK协议在条件为$\vec{r}$ is not useful的接受概率是$\frac{(d_{max} + 2^h + a) \cdot \ell^2}{|\mathbb{K}|-a|\mathsf{D}| + |\mathsf{H}_0|} + \epsilon_{\mathsf{FRI}}$.

$\vec{r}$ is useful的概率是$\frac{\ell}{|\mathbb{K}|}$。假设$\vec{P}_k$是使得$\vec{r}$ is useful的概率最大的集合。这个概率一定严格大于$\frac{1}{|\mathbb{K}|}$，即从$\mathbb{K}$中随机选一个的概率。因此，useful的$\vec{r}$组成的集合中一定包含了能够张成$\mathbb{K}^{2s}$一组基（线性独立的一组随机值）。根据引理4，这个$\vec{P}_k$是满足AIR实例的assignment，也就是witness。